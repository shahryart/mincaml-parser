processing file `mincaml.lalrpop`
mincaml.lalrpop:71:5: 71:9: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp "," elems "," exp

  They could be reduced like so:
    exp "," elems ╷ "," exp
    │       └─exp─┤       │
    ├─elems───────┘       │
    └─elems───────────────┘

  Alternatively, they could be reduced like so:
    exp "," elems "," exp
    │       ├─elems─────┤
    │       └─exp───────┤
    └─elems─────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"("` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"*."` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"+"` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"+."` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `","` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"-"` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"-."` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"/."` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `";"` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"<"` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"<="` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"<>"` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `">"` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `">="` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"false"` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"true"` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `r#"([_a-z]+)([0-9a-zA-z_]*)"#` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `r#"\\d+"#` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:81:5: 81:36: Conflict detected

    when in this state:
  actual_args = (*) actual_args simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  actual_args = (*) simple_exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "false" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  boolean = (*) "true" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  elems = exp (*) "," exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) actual_args ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) minus exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) operator exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) "-." exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = exp (*) ";" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  floating = (*) r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  function_def = identifier formal_args equal exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  identifier = (*) r#"([_a-z]+)([0-9a-zA-z_]*)"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  integer = (*) r#"\\d+"# ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  minus = (*) "-" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "*." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "+." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "/." ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) "<>" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  operator = (*) ">=" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) boolean ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) floating ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) identifier ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) integer ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) simple_exp "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = (*) "(" ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` we can reduce to a `function_def` but we can also shift

mincaml.lalrpop:64:5: 64:14: Conflict detected

    when in this state:
  exp = simple_exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = simple_exp (*) ".(" exp ")" "<-" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = simple_exp (*) "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"."` we can reduce to a `exp` but we can also shift

mincaml.lalrpop:64:5: 64:14: Conflict detected

    when in this state:
  exp = simple_exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  exp = simple_exp (*) ".(" exp ")" "<-" exp ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = simple_exp (*) "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `".("` we can reduce to a `exp` but we can also shift

mincaml.lalrpop:70:5: 70:19: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp actual_args
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:70:5: 70:19, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp actual_args actual_args
    ├─exp─────────┘           │
    └─exp─────────────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    actual_args "("        ")"
    │           └─simple_exp─┤
    └─actual_args────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:70:5: 70:19: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp actual_args
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:70:5: 70:19, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp actual_args actual_args
    ├─exp─────────┘           │
    └─exp─────────────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    actual_args "false"      ╷
    │           ├─boolean────┤
    │           └─simple_exp─┤
    └─actual_args────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:70:5: 70:19: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp actual_args
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:70:5: 70:19, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp actual_args actual_args
    ├─exp─────────┘           │
    └─exp─────────────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    actual_args "true"       ╷
    │           ├─boolean────┤
    │           └─simple_exp─┤
    └─actual_args────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:70:5: 70:19: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp actual_args
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:70:5: 70:19, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp actual_args actual_args
    ├─exp─────────┘           │
    └─exp─────────────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    actual_args r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │           ├─identifier────────────────┤
    │           └─simple_exp────────────────┤
    └─actual_args───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:70:5: 70:19: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp actual_args
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:70:5: 70:19, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp actual_args actual_args
    ├─exp─────────┘           │
    └─exp─────────────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    actual_args r#"\\d+"#    ╷
    │           ├─integer────┤
    │           └─simple_exp─┤
    └─actual_args────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:70:5: 70:19: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp actual_args
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:70:5: 70:19, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp actual_args actual_args
    ├─exp─────────┘           │
    └─exp─────────────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    actual_args r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │           ├─floating─────────────────────────────┤
    │           └─simple_exp───────────────────────────┤
    └─actual_args──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:92:5: 92:14: Conflict detected

    when in this state:
  actual_args = simple_exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = simple_exp (*) "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"."` we can reduce to a `actual_args` but we can also shift

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp actual_args
    ├─exp───┘           │
    └─exp───────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp operator exp
    ├─exp───┘            │
    └─exp────────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp operator exp
    ├─exp───┘            │
    └─exp────────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp operator exp
    ├─exp───┘            │
    └─exp────────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    minus exp "," exp

  They could be reduced like so:
    minus exp "," exp
    ├─exp───┘       │
    └─elems─────────┘

  Alternatively, they could be reduced like so:
    minus exp "," exp
    │     ├─elems───┤
    │     └─exp─────┤
    └─exp───────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp minus exp
    ├─exp───┘         │
    └─exp─────────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    minus exp "-." exp

  They could be reduced like so:
    minus exp "-." exp
    ├─exp───┘        │
    └─exp────────────┘

  Alternatively, they could be reduced like so:
    minus exp "-." exp
    │     └─exp──────┤
    └─exp────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp operator exp
    ├─exp───┘            │
    └─exp────────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    minus exp ";" exp

  They could be reduced like so:
    minus exp ";" exp
    ├─exp───┘       │
    └─exp───────────┘

  Alternatively, they could be reduced like so:
    minus exp ";" exp
    │     └─exp─────┤
    └─exp───────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp operator exp
    ├─exp───┘            │
    └─exp────────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp operator exp
    ├─exp───┘            │
    └─exp────────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp operator exp
    ├─exp───┘            │
    └─exp────────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp operator exp
    ├─exp───┘            │
    └─exp────────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp operator exp
    ├─exp───┘            │
    └─exp────────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp actual_args
    ├─exp───┘           │
    └─exp───────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp actual_args
    ├─exp───┘           │
    └─exp───────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp actual_args
    ├─exp───┘           │
    └─exp───────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp actual_args
    ├─exp───┘           │
    └─exp───────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:66:5: 66:13: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    minus exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:66:5: 66:13, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    minus exp actual_args
    ├─exp───┘           │
    └─exp───────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp actual_args
    ├─exp─┘           │
    └─exp─────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp operator exp
    ├─exp─┘            │
    └─exp──────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp operator exp
    ├─exp─┘            │
    └─exp──────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp operator exp
    ├─exp─┘            │
    └─exp──────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    not exp "," exp

  They could be reduced like so:
    not exp "," exp
    ├─exp─┘       │
    └─elems───────┘

  Alternatively, they could be reduced like so:
    not exp "," exp
    │   ├─elems───┤
    │   └─exp─────┤
    └─exp─────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp minus exp
    ├─exp─┘         │
    └─exp───────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    not exp "-." exp

  They could be reduced like so:
    not exp "-." exp
    ├─exp─┘        │
    └─exp──────────┘

  Alternatively, they could be reduced like so:
    not exp "-." exp
    │   └─exp──────┤
    └─exp──────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp operator exp
    ├─exp─┘            │
    └─exp──────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    not exp ";" exp

  They could be reduced like so:
    not exp ";" exp
    ├─exp─┘       │
    └─exp─────────┘

  Alternatively, they could be reduced like so:
    not exp ";" exp
    │   └─exp─────┤
    └─exp─────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp operator exp
    ├─exp─┘            │
    └─exp──────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp operator exp
    ├─exp─┘            │
    └─exp──────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp operator exp
    ├─exp─┘            │
    └─exp──────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp operator exp
    ├─exp─┘            │
    └─exp──────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp operator exp
    ├─exp─┘            │
    └─exp──────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp actual_args
    ├─exp─┘           │
    └─exp─────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp actual_args
    ├─exp─┘           │
    └─exp─────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp actual_args
    ├─exp─┘           │
    └─exp─────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp actual_args
    ├─exp─┘           │
    └─exp─────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:65:5: 65:11: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    not exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:65:5: 65:11, which would consume the top 2 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    not exp actual_args
    ├─exp─┘           │
    └─exp─────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp actual_args
    ├─elems─────┤           │
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp operator exp
    ├─elems─────┤            │
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp operator exp
    ├─elems─────┤            │
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp operator exp
    ├─elems─────┤            │
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    elems "," exp "," exp

  They could be reduced like so:
    elems "," exp "," exp
    ├─elems─────┤       │
    ├─exp───────┘       │
    └─elems─────────────┘

  Alternatively, they could be reduced like so:
    elems "," exp "," exp
    │         ├─elems───┤
    │         └─exp─────┤
    └─elems─────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp minus exp
    ├─elems─────┤         │
    ├─exp───────┘         │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    elems "," exp "-." exp

  They could be reduced like so:
    elems "," exp "-." exp
    ├─elems─────┤        │
    ├─exp───────┘        │
    └─exp────────────────┘

  Alternatively, they could be reduced like so:
    elems "," exp "-." exp
    │         └─exp──────┤
    └─elems──────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp operator exp
    ├─elems─────┤            │
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    elems "," exp ";" exp

  They could be reduced like so:
    elems "," exp ";" exp
    ├─elems─────┤       │
    ├─exp───────┘       │
    └─exp───────────────┘

  Alternatively, they could be reduced like so:
    elems "," exp ";" exp
    │         └─exp─────┤
    └─elems─────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp operator exp
    ├─elems─────┤            │
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp operator exp
    ├─elems─────┤            │
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp operator exp
    ├─elems─────┤            │
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp operator exp
    ├─elems─────┤            │
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp operator exp
    ├─elems─────┤            │
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp actual_args
    ├─elems─────┤           │
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp actual_args
    ├─elems─────┤           │
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp actual_args
    ├─elems─────┤           │
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp actual_args
    ├─elems─────┤           │
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:96:5: 96:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    elems "," exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:96:5: 96:17, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    elems "," exp actual_args
    ├─elems─────┤           │
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:91:5: 91:26: Conflict detected

    when in this state:
  actual_args = actual_args simple_exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = simple_exp (*) "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"."` we can reduce to a `actual_args` but we can also shift

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp actual_args
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp operator exp
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp operator exp
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp operator exp
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp minus exp "," exp

  They could be reduced like so:
    exp minus exp "," exp
    ├─exp───────┘       │
    └─elems─────────────┘

  Alternatively, they could be reduced like so:
    exp minus exp "," exp
    │         ├─elems───┤
    │         └─exp─────┤
    └─exp───────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp minus exp
    ├─exp───────┘         │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp minus exp "-." exp

  They could be reduced like so:
    exp minus exp "-." exp
    ├─exp───────┘        │
    └─exp────────────────┘

  Alternatively, they could be reduced like so:
    exp minus exp "-." exp
    │         └─exp──────┤
    └─exp────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp operator exp
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp minus exp ";" exp

  They could be reduced like so:
    exp minus exp ";" exp
    ├─exp───────┘       │
    └─exp───────────────┘

  Alternatively, they could be reduced like so:
    exp minus exp ";" exp
    │         └─exp─────┤
    └─exp───────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp operator exp
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp operator exp
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp operator exp
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp operator exp
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp operator exp
    ├─exp───────┘            │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp actual_args
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp actual_args
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp actual_args
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp actual_args
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:67:5: 67:17: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp minus exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:67:5: 67:17, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp minus exp actual_args
    ├─exp───────┘           │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp actual_args
    ├─exp──────────┘           │
    └─exp──────────────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp operator exp
    ├─exp──────────┘            │
    └─exp───────────────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp operator exp
    ├─exp──────────┘            │
    └─exp───────────────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp operator exp
    ├─exp──────────┘            │
    └─exp───────────────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp operator exp "," exp

  They could be reduced like so:
    exp operator exp "," exp
    ├─exp──────────┘       │
    └─elems────────────────┘

  Alternatively, they could be reduced like so:
    exp operator exp "," exp
    │            ├─elems───┤
    │            └─exp─────┤
    └─exp──────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp minus exp
    ├─exp──────────┘         │
    └─exp────────────────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp operator exp "-." exp

  They could be reduced like so:
    exp operator exp "-." exp
    ├─exp──────────┘        │
    └─exp───────────────────┘

  Alternatively, they could be reduced like so:
    exp operator exp "-." exp
    │            └─exp──────┤
    └─exp───────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp operator exp
    ├─exp──────────┘            │
    └─exp───────────────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp operator exp ";" exp

  They could be reduced like so:
    exp operator exp ";" exp
    ├─exp──────────┘       │
    └─exp──────────────────┘

  Alternatively, they could be reduced like so:
    exp operator exp ";" exp
    │            └─exp─────┤
    └─exp──────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp operator exp
    ├─exp──────────┘            │
    └─exp───────────────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp operator exp
    ├─exp──────────┘            │
    └─exp───────────────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp operator exp
    ├─exp──────────┘            │
    └─exp───────────────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp operator exp
    ├─exp──────────┘            │
    └─exp───────────────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp operator exp
    ├─exp──────────┘            │
    └─exp───────────────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp actual_args
    ├─exp──────────┘           │
    └─exp──────────────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp actual_args
    ├─exp──────────┘           │
    └─exp──────────────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp actual_args
    ├─exp──────────┘           │
    └─exp──────────────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp actual_args
    ├─exp──────────┘           │
    └─exp──────────────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:68:5: 68:20: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp operator exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:68:5: 68:20, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp operator exp actual_args
    ├─exp──────────┘           │
    └─exp──────────────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp actual_args
    ├─elems───┤           │
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp operator exp
    ├─elems───┤            │
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp operator exp
    ├─elems───┤            │
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp operator exp
    ├─elems───┤            │
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp "," exp "," exp

  They could be reduced like so:
    exp "," exp "," exp
    ├─elems───┤       │
    ├─exp─────┘       │
    └─elems───────────┘

  Alternatively, they could be reduced like so:
    exp "," exp "," exp
    │       ├─elems───┤
    │       └─exp─────┤
    └─elems───────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp minus exp
    ├─elems───┤         │
    ├─exp─────┘         │
    └─exp───────────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp "," exp "-." exp

  They could be reduced like so:
    exp "," exp "-." exp
    ├─elems───┤        │
    ├─exp─────┘        │
    └─exp──────────────┘

  Alternatively, they could be reduced like so:
    exp "," exp "-." exp
    │       └─exp──────┤
    └─elems────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp operator exp
    ├─elems───┤            │
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp "," exp ";" exp

  They could be reduced like so:
    exp "," exp ";" exp
    ├─elems───┤       │
    ├─exp─────┘       │
    └─exp─────────────┘

  Alternatively, they could be reduced like so:
    exp "," exp ";" exp
    │       └─exp─────┤
    └─elems───────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp operator exp
    ├─elems───┤            │
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp operator exp
    ├─elems───┤            │
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp operator exp
    ├─elems───┤            │
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp operator exp
    ├─elems───┤            │
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp operator exp
    ├─elems───┤            │
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp actual_args
    ├─elems───┤           │
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp actual_args
    ├─elems───┤           │
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp actual_args
    ├─elems───┤           │
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp actual_args
    ├─elems───┤           │
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:97:5: 97:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "," exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:97:5: 97:15, which would consume the top 3 token(s) from the stack and produce a `elems`. This might then yield a parse tree like
    exp "," exp actual_args
    ├─elems───┤           │
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp actual_args
    ├─exp──────┘           │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp operator exp
    ├─exp──────┘            │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp operator exp
    ├─exp──────┘            │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp operator exp
    ├─exp──────┘            │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp "-." exp "," exp

  They could be reduced like so:
    exp "-." exp "," exp
    ├─exp──────┘       │
    └─elems────────────┘

  Alternatively, they could be reduced like so:
    exp "-." exp "," exp
    │        ├─elems───┤
    │        └─exp─────┤
    └─exp──────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp minus exp
    ├─exp──────┘         │
    └─exp────────────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp "-." exp "-." exp

  They could be reduced like so:
    exp "-." exp "-." exp
    ├─exp──────┘        │
    └─exp───────────────┘

  Alternatively, they could be reduced like so:
    exp "-." exp "-." exp
    │        └─exp──────┤
    └─exp───────────────┘

  Hint: This looks like a precedence error related to `exp`. See the LALRPOP manual for advice on encoding precedence.

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp operator exp
    ├─exp──────┘            │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp "-." exp ";" exp

  They could be reduced like so:
    exp "-." exp ";" exp
    ├─exp──────┘       │
    └─exp──────────────┘

  Alternatively, they could be reduced like so:
    exp "-." exp ";" exp
    │        └─exp─────┤
    └─exp──────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp operator exp
    ├─exp──────┘            │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp operator exp
    ├─exp──────┘            │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp operator exp
    ├─exp──────┘            │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp operator exp
    ├─exp──────┘            │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp operator exp
    ├─exp──────┘            │
    └─exp───────────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp actual_args
    ├─exp──────┘           │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp actual_args
    ├─exp──────┘           │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp actual_args
    ├─exp──────┘           │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp actual_args
    ├─exp──────┘           │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:69:5: 69:16: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp "-." exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:69:5: 69:16, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp "-." exp actual_args
    ├─exp──────┘           │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp actual_args
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp operator exp
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp operator exp
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp operator exp
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp ";" exp "," exp

  They could be reduced like so:
    exp ";" exp "," exp
    ├─exp─────┘       │
    └─elems───────────┘

  Alternatively, they could be reduced like so:
    exp ";" exp "," exp
    │       ├─elems───┤
    │       └─exp─────┤
    └─exp─────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp minus exp
    ├─exp─────┘         │
    └─exp───────────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp ";" exp "-." exp

  They could be reduced like so:
    exp ";" exp "-." exp
    ├─exp─────┘        │
    └─exp──────────────┘

  Alternatively, they could be reduced like so:
    exp ";" exp "-." exp
    │       └─exp──────┤
    └─exp──────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp operator exp
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp ";" exp ";" exp

  They could be reduced like so:
    exp ";" exp ";" exp
    ├─exp─────┘       │
    └─exp─────────────┘

  Alternatively, they could be reduced like so:
    exp ";" exp ";" exp
    │       └─exp─────┤
    └─exp─────────────┘

  Hint: This looks like a precedence error related to `exp`. See the LALRPOP manual for advice on encoding precedence.

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp operator exp
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp operator exp
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp operator exp
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp operator exp
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp operator exp
    ├─exp─────┘            │
    └─exp──────────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp actual_args
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp actual_args
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp actual_args
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp actual_args
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:76:5: 76:15: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    exp ";" exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:76:5: 76:15, which would consume the top 3 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    exp ";" exp actual_args
    ├─exp─────┘           │
    └─exp─────────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:77:5: 77:40: Conflict detected

    when in this state:
  exp = "Array.create" simple_exp simple_exp (*) ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]
  simple_exp = simple_exp (*) "." "(" exp ")" ["(", ")", "*.", "+", "+.", ",", "-", "-.", ".", ".(", "/.", ";", "<", "<-", "<=", "<>", "=", ">", ">=", "Array.create", "else", "false", "if", "in", "let", "let rec", "not", "then", "true", r#"([_a-z]+)([0-9a-zA-z_]*)"#, r#"\\d+"#, r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#, EOF]

  and looking at a token `"."` we can reduce to a `exp` but we can also shift

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp actual_args
    ├─exp──────────────────────────┘           │
    └─exp──────────────────────────────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp operator exp
    ├─exp──────────────────────────┘            │
    └─exp───────────────────────────────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp operator exp
    ├─exp──────────────────────────┘            │
    └─exp───────────────────────────────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp operator exp
    ├─exp──────────────────────────┘            │
    └─exp───────────────────────────────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    simple_exp ".(" exp ")" "<-" exp "," exp

  They could be reduced like so:
    simple_exp ".(" exp ")" "<-" exp "," exp
    ├─exp──────────────────────────┘       │
    └─elems────────────────────────────────┘

  Alternatively, they could be reduced like so:
    simple_exp ".(" exp ")" "<-" exp "," exp
    │                            ├─elems───┤
    │                            └─exp─────┤
    └─exp──────────────────────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp minus exp
    ├─exp──────────────────────────┘         │
    └─exp────────────────────────────────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    simple_exp ".(" exp ")" "<-" exp "-." exp

  They could be reduced like so:
    simple_exp ".(" exp ")" "<-" exp "-." exp
    ├─exp──────────────────────────┘        │
    └─exp───────────────────────────────────┘

  Alternatively, they could be reduced like so:
    simple_exp ".(" exp ")" "<-" exp "-." exp
    │                            └─exp──────┤
    └─exp───────────────────────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp operator exp
    ├─exp──────────────────────────┘            │
    └─exp───────────────────────────────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    simple_exp ".(" exp ")" "<-" exp ";" exp

  They could be reduced like so:
    simple_exp ".(" exp ")" "<-" exp ";" exp
    ├─exp──────────────────────────┘       │
    └─exp──────────────────────────────────┘

  Alternatively, they could be reduced like so:
    simple_exp ".(" exp ")" "<-" exp ";" exp
    │                            └─exp─────┤
    └─exp──────────────────────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp operator exp
    ├─exp──────────────────────────┘            │
    └─exp───────────────────────────────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp operator exp
    ├─exp──────────────────────────┘            │
    └─exp───────────────────────────────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp operator exp
    ├─exp──────────────────────────┘            │
    └─exp───────────────────────────────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp operator exp
    ├─exp──────────────────────────┘            │
    └─exp───────────────────────────────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp operator exp
    ├─exp──────────────────────────┘            │
    └─exp───────────────────────────────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp actual_args
    ├─exp──────────────────────────┘           │
    └─exp──────────────────────────────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp actual_args
    ├─exp──────────────────────────┘           │
    └─exp──────────────────────────────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp actual_args
    ├─exp──────────────────────────┘           │
    └─exp──────────────────────────────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp actual_args
    ├─exp──────────────────────────┘           │
    └─exp──────────────────────────────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:75:5: 75:36: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    simple_exp ".(" exp ")" "<-" exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:75:5: 75:36, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    simple_exp ".(" exp ")" "<-" exp actual_args
    ├─exp──────────────────────────┘           │
    └─exp──────────────────────────────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp actual_args
    ├─exp────────────────────────┘           │
    └─exp────────────────────────────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp operator exp
    ├─exp────────────────────────┘            │
    └─exp─────────────────────────────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp operator exp
    ├─exp────────────────────────┘            │
    └─exp─────────────────────────────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp operator exp
    ├─exp────────────────────────┘            │
    └─exp─────────────────────────────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    "if" exp "then" exp "else" exp "," exp

  They could be reduced like so:
    "if" exp "then" exp "else" exp "," exp
    ├─exp────────────────────────┘       │
    └─elems──────────────────────────────┘

  Alternatively, they could be reduced like so:
    "if" exp "then" exp "else" exp "," exp
    │                          ├─elems───┤
    │                          └─exp─────┤
    └─exp────────────────────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp minus exp
    ├─exp────────────────────────┘         │
    └─exp──────────────────────────────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    "if" exp "then" exp "else" exp "-." exp

  They could be reduced like so:
    "if" exp "then" exp "else" exp "-." exp
    ├─exp────────────────────────┘        │
    └─exp─────────────────────────────────┘

  Alternatively, they could be reduced like so:
    "if" exp "then" exp "else" exp "-." exp
    │                          └─exp──────┤
    └─exp─────────────────────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp operator exp
    ├─exp────────────────────────┘            │
    └─exp─────────────────────────────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    "if" exp "then" exp "else" exp ";" exp

  They could be reduced like so:
    "if" exp "then" exp "else" exp ";" exp
    ├─exp────────────────────────┘       │
    └─exp────────────────────────────────┘

  Alternatively, they could be reduced like so:
    "if" exp "then" exp "else" exp ";" exp
    │                          └─exp─────┤
    └─exp────────────────────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp operator exp
    ├─exp────────────────────────┘            │
    └─exp─────────────────────────────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp operator exp
    ├─exp────────────────────────┘            │
    └─exp─────────────────────────────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp operator exp
    ├─exp────────────────────────┘            │
    └─exp─────────────────────────────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp operator exp
    ├─exp────────────────────────┘            │
    └─exp─────────────────────────────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp operator exp
    ├─exp────────────────────────┘            │
    └─exp─────────────────────────────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp actual_args
    ├─exp────────────────────────┘           │
    └─exp────────────────────────────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp actual_args
    ├─exp────────────────────────┘           │
    └─exp────────────────────────────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp actual_args
    ├─exp────────────────────────┘           │
    └─exp────────────────────────────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp actual_args
    ├─exp────────────────────────┘           │
    └─exp────────────────────────────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:72:5: 72:34: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "if" exp "then" exp "else" exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:72:5: 72:34, which would consume the top 6 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "if" exp "then" exp "else" exp actual_args
    ├─exp────────────────────────┘           │
    └─exp────────────────────────────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"("`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp actual_args
    ├─exp──────────────────────────────────────────────────────────────┘           │
    └─exp──────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"("` token and later use it to construct a `simple_exp`. This might then yield a parse tree like
    exp "("         ")"
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"*."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp operator exp
    ├─exp──────────────────────────────────────────────────────────────┘            │
    └─exp───────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"*."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "*."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"+"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp operator exp
    ├─exp──────────────────────────────────────────────────────────────┘            │
    └─exp───────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"+"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"+."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp operator exp
    ├─exp──────────────────────────────────────────────────────────────┘            │
    └─exp───────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"+."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "+."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp "," exp

  They could be reduced like so:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp "," exp
    ├─exp──────────────────────────────────────────────────────────────┘       │
    └─elems────────────────────────────────────────────────────────────────────┘

  Alternatively, they could be reduced like so:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp "," exp
    │                                                                ├─elems───┤
    │                                                                └─exp─────┤
    └─exp──────────────────────────────────────────────────────────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"-"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp minus exp
    ├─exp──────────────────────────────────────────────────────────────┘         │
    └─exp────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"-"` token and later use it to construct a `minus`. This might then yield a parse tree like
    exp "-"     ╷ exp
    │   └─minus─┘   │
    └─exp───────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp "-." exp

  They could be reduced like so:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp "-." exp
    ├─exp──────────────────────────────────────────────────────────────┘        │
    └─exp───────────────────────────────────────────────────────────────────────┘

  Alternatively, they could be reduced like so:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp "-." exp
    │                                                                └─exp──────┤
    └─exp───────────────────────────────────────────────────────────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"/."`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp operator exp
    ├─exp──────────────────────────────────────────────────────────────┘            │
    └─exp───────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"/."` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "/."       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp ";" exp

  They could be reduced like so:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp ";" exp
    ├─exp──────────────────────────────────────────────────────────────┘       │
    └─exp──────────────────────────────────────────────────────────────────────┘

  Alternatively, they could be reduced like so:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp ";" exp
    │                                                                └─exp─────┤
    └─exp──────────────────────────────────────────────────────────────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"<"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp operator exp
    ├─exp──────────────────────────────────────────────────────────────┘            │
    └─exp───────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"<"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"<="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp operator exp
    ├─exp──────────────────────────────────────────────────────────────┘            │
    └─exp───────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"<="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"<>"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp operator exp
    ├─exp──────────────────────────────────────────────────────────────┘            │
    └─exp───────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"<>"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp "<>"       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `">"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp operator exp
    ├─exp──────────────────────────────────────────────────────────────┘            │
    └─exp───────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `">"` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">"        ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `">="`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp operator exp
    ├─exp──────────────────────────────────────────────────────────────┘            │
    └─exp───────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `">="` token and later use it to construct a `operator`. This might then yield a parse tree like
    exp ">="       ╷ exp
    │   └─operator─┘   │
    └─exp──────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"false"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp actual_args
    ├─exp──────────────────────────────────────────────────────────────┘           │
    └─exp──────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"false"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "false"       ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `"true"`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp actual_args
    ├─exp──────────────────────────────────────────────────────────────┘           │
    └─exp──────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `"true"` token and later use it to construct a `boolean`. This might then yield a parse tree like
    exp "true"        ╷
    │   ├─boolean─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `r#"([_a-z]+)([0-9a-zA-z_]*)"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp actual_args
    ├─exp──────────────────────────────────────────────────────────────┘           │
    └─exp──────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `r#"([_a-z]+)([0-9a-zA-z_]*)"#` token and later use it to construct a `identifier`. This might then yield a parse tree like
    exp r#"([_a-z]+)([0-9a-zA-z_]*)"#
    │   ├─identifier────────────────┤
    │   ├─simple_exp────────────────┤
    │   └─actual_args───────────────┤
    └─exp───────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `r#"\\d+"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp actual_args
    ├─exp──────────────────────────────────────────────────────────────┘           │
    └─exp──────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `r#"\\d+"#` token and later use it to construct a `integer`. This might then yield a parse tree like
    exp r#"\\d+"#     ╷
    │   ├─integer─────┤
    │   ├─simple_exp──┤
    │   └─actual_args─┤
    └─exp─────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:73:5: 74:35: Local ambiguity detected

  The problem arises after having observed the following symbols in the input:
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp
  At that point, if the next token is a `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#`, then the parser can proceed in two different ways.

  First, the parser could execute the production at mincaml.lalrpop:73:5: 74:35, which would consume the top 12 token(s) from the stack and produce a `exp`. This might then yield a parse tree like
    "let" "(" pat ")" equal exp "in" exp "let rec" function_def "in" exp actual_args
    ├─exp──────────────────────────────────────────────────────────────┘           │
    └─exp──────────────────────────────────────────────────────────────────────────┘

  Alternatively, the parser could shift the `r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#` token and later use it to construct a `floating`. This might then yield a parse tree like
    exp r#"\\d+ (\\. \\d*)? ([eE] [+-]? \\d+)?"#
    │   ├─floating─────────────────────────────┤
    │   ├─simple_exp───────────────────────────┤
    │   └─actual_args──────────────────────────┤
    └─exp──────────────────────────────────────┘

  See the LALRPOP manual for advice on making your grammar LR(1).

mincaml.lalrpop:71:5: 71:9: Ambiguous grammar detected

  The following symbols can be reduced in two ways:
    exp "," elems "," exp

  They could be reduced like so:
    exp "," elems ╷ "," exp
    │       └─exp─┤       │
    ├─elems───────┘       │
    └─elems───────────────┘

  Alternatively, they could be reduced like so:
    exp "," elems "," exp
    │       ├─elems─────┤
    │       └─exp───────┤
    └─elems─────────────┘

  LALRPOP does not yet support ambiguous grammars. See the LALRPOP manual for advice on making your grammar unambiguous.
